#!/bin/bash
#
# VPN Manager v5 - Split Routing para Pi-hole
# Gestiona WireGuard con enrutamiento selectivo por dominio
#
# Uso: vpn-manager {status|vpn-up|vpn-down|split-mode|all-vpn|add-domain|remove-domain|list-domains}
#

set -e

# === CONFIGURACIÓN ===
WG_INTERFACE="wg-us"
DOMAINS_FILE="/etc/pihole/vpn-domains.txt"
DNSMASQ_VPN_CONF="/etc/dnsmasq.d/07-vpn-domains.conf"
IPSET_NAME="vpn-domains"
TABLE_ID="51"
FWMARK="51"

# Endpoint VPN (SIEMPRE excluido del routing VPN)
VPN_ENDPOINT="3.235.240.175"

# Rangos de Telegram (SIEMPRE excluidos)
TELEGRAM_RANGES="149.154.160.0/20 91.108.4.0/22 91.108.8.0/22 91.108.12.0/22 91.108.16.0/22 91.108.56.0/22"

# === FUNCIONES ===

log() {
    echo "[$(date '+%H:%M:%S')] $1"
}

error() {
    echo "error:$1" >&2
    exit 1
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
        error "Este script requiere privilegios de root"
    fi
}

# Verifica si WireGuard está activo y con handshake reciente
check_vpn_status() {
    if ! ip link show "$WG_INTERFACE" &>/dev/null; then
        echo "down"
        return
    fi

    local handshake
    handshake=$(wg show "$WG_INTERFACE" latest-handshakes 2>/dev/null | awk '{print $2}')

    if [[ -z "$handshake" || "$handshake" == "0" ]]; then
        echo "stale"
        return
    fi

    local now
    now=$(date +%s)
    local diff=$((now - handshake))

    # Si handshake > 3 minutos, consideramos stale
    if [[ $diff -gt 180 ]]; then
        echo "stale"
    else
        echo "active"
    fi
}

# Obtiene la IP pública del endpoint VPN
get_vpn_ip() {
    wg show "$WG_INTERFACE" endpoints 2>/dev/null | awk -F: '{print $1}' | awk '{print $2}'
}

# Cuenta dominios en la lista
count_domains() {
    if [[ -f "$DOMAINS_FILE" ]]; then
        grep -c '^[^#]' "$DOMAINS_FILE" 2>/dev/null || echo "0"
    else
        echo "0"
    fi
}

# Detecta el modo actual (split o all)
detect_mode() {
    if iptables-save -t mangle 2>/dev/null | grep -q '! -d 192.168.0.0/24'; then
        echo "all"
    else
        echo "split"
    fi
}

# Crea el ipset si no existe
ensure_ipset() {
    if ! ipset list "$IPSET_NAME" &>/dev/null; then
        ipset create "$IPSET_NAME" hash:ip timeout 86400
    fi
}

# Configura reglas base (exclusiones que siempre deben estar)
setup_base_rules() {
    # Limpiar tablas mangle existentes
    iptables -t mangle -F OUTPUT 2>/dev/null || true
    iptables -t mangle -F PREROUTING 2>/dev/null || true

    # Exclusiones críticas: Telegram (siempre directo)
    for net in $TELEGRAM_RANGES; do
        iptables -t mangle -A OUTPUT -d "$net" -j RETURN
        iptables -t mangle -A PREROUTING -d "$net" -j RETURN
    done

    # Exclusión: endpoint VPN (CRÍTICO - sin esto el túnel se rompe)
    iptables -t mangle -A OUTPUT -d "$VPN_ENDPOINT" -j RETURN
    iptables -t mangle -A PREROUTING -d "$VPN_ENDPOINT" -j RETURN

    # Exclusión: red local
    iptables -t mangle -A OUTPUT -d 192.168.0.0/24 -j RETURN
    iptables -t mangle -A PREROUTING -d 192.168.0.0/24 -j RETURN
}

# Configura routing por policy
setup_policy_routing() {
    # Limpiar regla existente
    ip rule del fwmark "$FWMARK" table "$TABLE_ID" 2>/dev/null || true

    # Añadir regla
    ip rule add fwmark "$FWMARK" table "$TABLE_ID"

    # Configurar tabla de rutas
    ip route flush table "$TABLE_ID" 2>/dev/null || true
    ip route add default dev "$WG_INTERFACE" table "$TABLE_ID"
}

# Genera configuración dnsmasq para dominios VPN
generate_dnsmasq_config() {
    if [[ ! -f "$DOMAINS_FILE" ]]; then
        touch "$DOMAINS_FILE"
    fi

    echo "# Auto-generated by vpn-manager" > "$DNSMASQ_VPN_CONF"
    echo "# Dominios que se enrutan por VPN" >> "$DNSMASQ_VPN_CONF"
    echo "" >> "$DNSMASQ_VPN_CONF"

    while IFS= read -r domain; do
        [[ -z "$domain" || "$domain" =~ ^# ]] && continue
        echo "ipset=/$domain/$IPSET_NAME" >> "$DNSMASQ_VPN_CONF"
    done < "$DOMAINS_FILE"

    # Recargar dnsmasq (dentro de Docker)
    docker exec pihole pihole restartdns reload-lists 2>/dev/null || true
}

# === COMANDOS ===

cmd_status() {
    local vpn_status
    vpn_status=$(check_vpn_status)
    local domain_count
    domain_count=$(count_domains)
    local vpn_ip
    vpn_ip=$(get_vpn_ip)
    local mode
    mode=$(detect_mode)

    echo "vpn:$vpn_status"
    echo "mode:$mode"
    echo "domains:$domain_count"
    echo "ip:${vpn_ip:-none}"
}

cmd_vpn_up() {
    check_root

    if ip link show "$WG_INTERFACE" &>/dev/null; then
        log "WireGuard ya está activo"
    else
        wg-quick up "$WG_INTERFACE"
        log "WireGuard iniciado"
    fi

    # Esperar a que el handshake se establezca
    sleep 2

    # Configurar routing
    ensure_ipset
    setup_base_rules
    setup_policy_routing

    # Modo split por defecto
    iptables -t mangle -A OUTPUT -m set --match-set "$IPSET_NAME" dst -j MARK --set-mark "$FWMARK"
    iptables -t mangle -A PREROUTING -m set --match-set "$IPSET_NAME" dst -j MARK --set-mark "$FWMARK"

    # Regenerar config dnsmasq
    generate_dnsmasq_config

    echo "ok:vpn up and split mode active"
}

cmd_vpn_down() {
    check_root

    # Limpiar reglas
    iptables -t mangle -F OUTPUT 2>/dev/null || true
    iptables -t mangle -F PREROUTING 2>/dev/null || true
    ip rule del fwmark "$FWMARK" table "$TABLE_ID" 2>/dev/null || true
    ip route flush table "$TABLE_ID" 2>/dev/null || true

    # Bajar WireGuard
    if ip link show "$WG_INTERFACE" &>/dev/null; then
        wg-quick down "$WG_INTERFACE"
        log "WireGuard detenido"
    fi

    echo "ok:vpn down"
}

cmd_split_mode() {
    check_root

    local vpn_status
    vpn_status=$(check_vpn_status)

    if [[ "$vpn_status" == "down" ]]; then
        error "VPN no está conectada"
    fi

    ensure_ipset
    setup_base_rules
    setup_policy_routing

    # Solo marcar tráfico hacia IPs en ipset
    iptables -t mangle -A OUTPUT -m set --match-set "$IPSET_NAME" dst -j MARK --set-mark "$FWMARK"
    iptables -t mangle -A PREROUTING -m set --match-set "$IPSET_NAME" dst -j MARK --set-mark "$FWMARK"

    echo "ok:split mode active"
}

cmd_all_vpn() {
    check_root

    local vpn_status
    vpn_status=$(check_vpn_status)

    if [[ "$vpn_status" != "active" ]]; then
        error "VPN no está activa o tiene problemas de conexión"
    fi

    ensure_ipset
    setup_base_rules
    setup_policy_routing

    # Marcar TODO el tráfico excepto exclusiones (ya aplicadas en setup_base_rules)
    iptables -t mangle -A OUTPUT ! -d 192.168.0.0/24 -j MARK --set-mark "$FWMARK"
    iptables -t mangle -A PREROUTING ! -d 192.168.0.0/24 -j MARK --set-mark "$FWMARK"

    echo "ok:all-vpn mode active"
}

cmd_add_domain() {
    check_root

    local domain="$1"
    if [[ -z "$domain" ]]; then
        error "Uso: vpn-manager add-domain <dominio>"
    fi

    # Limpiar dominio
    domain=$(echo "$domain" | tr '[:upper:]' '[:lower:]' | sed 's/^www\.//')

    # Verificar si ya existe
    if grep -q "^${domain}$" "$DOMAINS_FILE" 2>/dev/null; then
        echo "exists:$domain"
        return 0
    fi

    # Añadir
    echo "$domain" >> "$DOMAINS_FILE"

    # Regenerar config
    generate_dnsmasq_config

    echo "ok:added $domain"
}

cmd_remove_domain() {
    check_root

    local domain="$1"
    if [[ -z "$domain" ]]; then
        error "Uso: vpn-manager remove-domain <dominio>"
    fi

    domain=$(echo "$domain" | tr '[:upper:]' '[:lower:]')

    if ! grep -q "^${domain}$" "$DOMAINS_FILE" 2>/dev/null; then
        echo "notfound:$domain"
        return 0
    fi

    # Eliminar
    sed -i "/^${domain}$/d" "$DOMAINS_FILE"

    # Regenerar config
    generate_dnsmasq_config

    echo "ok:removed $domain"
}

cmd_list_domains() {
    if [[ -f "$DOMAINS_FILE" ]]; then
        grep -v '^#' "$DOMAINS_FILE" | grep -v '^$' || true
    fi
}

# === MAIN ===

case "${1:-}" in
    status)
        cmd_status
        ;;
    vpn-up)
        cmd_vpn_up
        ;;
    vpn-down)
        cmd_vpn_down
        ;;
    split-mode)
        cmd_split_mode
        ;;
    all-vpn)
        cmd_all_vpn
        ;;
    add-domain)
        cmd_add_domain "$2"
        ;;
    remove-domain)
        cmd_remove_domain "$2"
        ;;
    list-domains)
        cmd_list_domains
        ;;
    *)
        echo "VPN Manager v5"
        echo ""
        echo "Uso: vpn-manager <comando>"
        echo ""
        echo "Comandos:"
        echo "  status          - Estado del VPN y routing"
        echo "  vpn-up          - Iniciar VPN + split mode"
        echo "  vpn-down        - Detener VPN"
        echo "  split-mode      - Activar modo split routing"
        echo "  all-vpn         - Todo el tráfico por VPN"
        echo "  add-domain      - Añadir dominio a la lista VPN"
        echo "  remove-domain   - Eliminar dominio de la lista"
        echo "  list-domains    - Listar dominios VPN"
        exit 1
        ;;
esac
